{"pageProps":{"post":{"slug":"metal-render-pipeline-part-6-transform-component-mesh-renderer","date":"2022-12-26T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Metal Render Pipeline Part 6: Transform, Components and MeshRenderer","excerpt":"Implementing the Transform objects which will form a tree structure to build the Scene Graph. Adding Components to the Game Object, so that different functionalities and behaviors can be composed inside a Game Object as a list of children components. Finally implementing a MeshRenderer component which will be in charge of rendering the 3D mesh associated with the Game Object.","heroImageUrl":"/resources/blog/metal-render-pipeline-part-6-transform-component-mesh-renderer/cover.jpg","heroImageSourceUrl":"","heroVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n\n---\n\n## Table of Content\n\n- [Transform](#transform)\n- [Component](#component)\n- [MeshRenderer](#meshrenderer)\n\n---\n\n## Transform\n\n![Picture](/resources/blog/metal-render-pipeline-part-6-transform-component-mesh-renderer/cover.jpg)\n\nThe **Transform** class will have information about **position**, **rotation** and **scale**.\n\nIt will also have a **list of children Transform objects**, to makeup the **Scene Graph** in the **Scene**.\n\nEverytime **render()** and **update()** are invoked on a Transform, it will iterate the children elements and invoke **render()** and **update()** on them.\n\nThen it will check if **itself** implements the **Renderable** or **Updatable** protocols, if yes, then it will proceed to invoke **doRender()** and **doUpdate()** on itself.\n\n```swift\nclass Transform {\n    public var children: [Transform]! = []\n\n    public func addChildren(transform: Transform){\n        children.append(transform)\n    }\n\n    public func update(deltaTime: Float){\n        for child in children {\n            child.update(deltaTime: deltaTime)\n        }\n\n        if let updatableSelf = self as? Updatable {\n            updatableSelf.doUpdate(deltaTime: deltaTime)\n        }\n    }\n\n    public func render(renderCommandEncoder: MTLRenderCommandEncoder){\n        for child in children {\n            child.render(renderCommandEncoder: renderCommandEncoder)\n        }\n\n        if let renderableSelf = self as? Renderable {\n            renderableSelf.doRender(renderCommandEncoder: renderCommandEncoder)\n        }\n    }\n}\n```\n\n---\n\n## Component\n\n**GameObject** will have a list of **components** that may or may not be **Renderable** or **Updatable**.\n\nOn **doRender()** and **doUpdate()**, the **GameObject** will iterate its components and invoke **doRender()** and **doUpdate()** accordingly.\n\n```swift\nclass GameObject : Transform {\n\n    public var components: [Component]! = []\n\n    public func addComponent(component: Component){\n        components.append(component)\n    }\n}\n\nextension GameObject : Updatable {\n    public func doUpdate(deltaTime: Float){\n        for component in components {\n            if let updatableComponent = component as? Updatable {\n                updatableComponent.doUpdate(deltaTime: deltaTime)\n            }\n        }\n    }\n}\n\nextension GameObject : Renderable {\n    public func doRender(renderCommandEncoder: MTLRenderCommandEncoder){\n        for component in components {\n            if let renderableComponent = component as? Renderable {\n                renderableComponent.doRender(renderCommandEncoder: renderCommandEncoder)\n            }\n        }\n    }\n}\n```\n\n---\n\n## MeshRenderer\n\nThe **MeshRenderer** component will be in charge of drawing the mesh using the **Metal** graphics API elements, like the render command encoder.\n\nIt will have a reference to a **Mesh** class.\n\n```swift\nclass MeshRenderer : Component, Renderable {\n    private var _vertexBuffer: MTLBuffer!\n    private var _mesh: Mesh!\n\n    init(mesh: Mesh) {\n        _mesh = mesh\n        _vertexBuffer = Engine.device.makeBuffer(bytes: _mesh.vertices, length: Vertex.stride * _mesh.vertices.count, options: [])\n    }\n\n    func doRender(renderCommandEncoder: MTLRenderCommandEncoder) {\n        renderCommandEncoder.setRenderPipelineState(RenderPipelineStateCache.getPipelineState(.Basic))\n        renderCommandEncoder.setVertexBuffer(_vertexBuffer, offset: 0, index: 0)\n        renderCommandEncoder.drawPrimitives(type: MTLPrimitiveType.triangle, vertexStart: 0, vertexCount: _mesh.vertices.count)\n    }\n}\n```\n\nThe **Mesh** class will have the **array of vertices** that will later be used by the **MeshRenderer** to create the **Vertex Buffer** off of.\n\n```swift\nclass Mesh {\n    public var vertices: [Vertex]!\n\n    init(){\n        createVertices()\n    }\n\n    func createVertices() {}\n}\n\nclass TriangleMesh : Mesh{\n    override func createVertices() {\n        vertices = [\n            Vertex(position: float3( 0, 1,0), color: float4(1,0,0,1)),\n            Vertex(position: float3(-1,-1,0), color: float4(0,1,0,1)),\n            Vertex(position: float3( 1,-1,0), color: float4(0,0,1,1))\n        ]\n    }\n}\n```\n"}},"__N_SSG":true}