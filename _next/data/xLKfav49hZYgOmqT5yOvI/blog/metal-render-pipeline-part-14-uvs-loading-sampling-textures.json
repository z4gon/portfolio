{"pageProps":{"post":{"slug":"metal-render-pipeline-part-14-uvs-loading-sampling-textures","date":"2023-01-01T01:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Metal Render Pipeline Part 14: UVs, Loading and Sampling Textures","excerpt":"Defining the UV coordinates in the vertices of the mesh, and also in the GPU structs used in the Vertex and Fragment functions. Initializing MTLTextures and MTLSamplerStates to handle texture sampling. Passing textures and samplers to the GPU from the material. Accessing the texture and sampler in the corresponding memory blocks in the GPU and sampling the texels using the UV coordinates in the fragment shader function.","coverImageUrl":"/images/blog/metal-render-pipeline-part-14-uvs-loading-sampling-textures/cover.jpg","coverImageSourceUrl":"","coverVideoUrl":"/videos/blog/metal-render-pipeline-part-14-uvs-loading-sampling-textures/1.mp4","markdownContent":"\n## Source Code\n\n[See Project in GitHub ðŸ‘©â€ðŸ’»](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n-   [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n-   [Mona Lisa Texture](https://unsplash.com/photos/cZveUvrezvY)\n\n## Table of Content\n\n-   [Vertex](#vertex)\n-   [Mesh](#mesh)\n-   [Basic UVs Shader](#basic-uvs-shader)\n-   [Texture](#texture)\n-   [Sampler](#sampler)\n-   [Material](#material)\n-   [Shader](#shader)\n-   [Result](#result)\n\n---\n\n## Vertex\n\nWe need to update the class that represents the **vertices** in the **mesh** by adding a new **float2** to represent the **uv coordinates**.\n\n```swift\nstruct Vertex: sizeable{\n    var position: float3\n    var color: float4\n    var uv: float2\n\n    init(\n        position: float3,\n        color: float4 = float4(repeating: 0),\n        uv: float2 = float2(repeating: 0)\n    ) {\n        self.position = position\n        self.color = color\n        self.uv = uv\n    }\n}\n```\n\nSimilarly, we also need to update the **MTLVertexDescriptor**.\n\n```swift\npublic struct BasicVertexDescriptor : VertexDescriptor{\n    ...\n\n    init(){\n        ...\n\n        // uv\n        vertexDescriptor.attributes[2].format = MTLVertexFormat.float2\n        vertexDescriptor.attributes[2].bufferIndex = 0\n        vertexDescriptor.attributes[2].offset = float3.size + float4.size\n\n        ...\n    }\n}\n```\n\nFinally, we also need to update the **VertexData** and **FragmentData** structs in the **GPU** side, and update the **basic_vertex_shader** to pass along the **uvs** to the fragments.\n\n### Structs\n\n```c\nstruct VertexData {\n    float3 position [[ attribute(0) ]];\n    float4 color [[ attribute(1) ]];\n    float2 uv [[ attribute(2) ]];\n};\n\nstruct FragmentData {\n    // use position attribute to prevent interpolation of the value\n    float4 position [[ position ]];\n    float4 color;\n    float2 uv;\n    float time;\n};\n```\n\n### Vertex Shader Function\n\n```c\nvertex FragmentData basic_vertex_shader(\n  // metal can infer the data because we are describing it using the vertex descriptor\n  const VertexData IN [[ stage_in ]],\n  constant ModelConstants &modelConstants [[ buffer(1) ]],\n  constant SceneConstants &sceneConstants [[ buffer(2) ]]\n){\n    FragmentData OUT;\n\n    ...\n\n    OUT.uv = IN.uv;\n\n    ...\n\n    return OUT;\n}\n```\n\n---\n\n## Mesh\n\nWe update the Quad mesh to have uv coordinates.\n\n```swift\nclass QuadMesh : Mesh{\n    override func createMesh() {\n        vertices = [\n            Vertex(position: float3( 0.5, 0.5,0), uv: float2(1,0)), //Top Right\n            Vertex(position: float3(-0.5, 0.5,0), uv: float2(0,0)), //Top Left\n            Vertex(position: float3(-0.5,-0.5,0), uv: float2(0,1)), //Bottom Left\n            Vertex(position: float3( 0.5,-0.5,0), uv: float2(1,1))  //Bottom Right\n        ]\n\n        indices = [\n            0,1,2,\n            0,2,3\n        ]\n    }\n}\n```\n\n---\n\n## Basic UVs Shader\n\nRight now we can define a **simple fragment shader** to display the **uv coordinates** **colors**, and also animate it using the **global game time**.\n\n```c\nfragment half4 uvs_fragment_shader(\n    const FragmentData IN [[ stage_in ]]\n){\n    return half4(\n        sin(IN.uv.x + IN.time),\n        sin(IN.uv.y + IN.time),\n        0,\n        1\n    );\n}\n```\n\n### UVs Gradient\n\n![Picture](/images/blog/metal-render-pipeline-part-14-uvs-loading-sampling-textures/1.jpg)\n\n---\n\n## Texture\n\nWe will create a cache to store built in textures, using **MTLTexture** and **MTKTextureLoader**.\n\n```swift\nclass TextureLoader {\n    private var _name: String!\n    private var _fileExtension: String!\n    private var _origin: MTKTextureLoader.Origin\n\n    ...\n\n    public func load()->MTLTexture {\n        var result: MTLTexture!\n\n        if let url = Bundle.main.url(forResource: _name, withExtension: _fileExtension) {\n\n            let loader = MTKTextureLoader(device: Engine.device)\n            let options: [MTKTextureLoader.Option: Any] = [MTKTextureLoader.Option.origin : _origin]\n\n            do {\n                result = try loader.newTexture(URL: url, options: options)\n                result.label = _name\n        ...\n\n        return result\n    }\n}\n```\n\n---\n\n## Sampler\n\nSimilarly, we will keep a cache of **MTLSamplerState** to use when sampling the textures.\n\n**Linear** means the **algorithm** that will be use when sampling textures, when the object is **minified** or **magnified** on screen.\n\n```swift\nclass LinearSamplerState : SamplerState {\n\n    override init() {\n        super.init()\n\n        let samplerDescriptor = MTLSamplerDescriptor()\n\n        samplerDescriptor.minFilter = .linear\n        samplerDescriptor.magFilter = .linear\n\n        samplerState = Engine.device.makeSamplerState(descriptor: samplerDescriptor)\n    }\n}\n```\n\n---\n\n## Material\n\nThe **material** will be in charge of passing the **Texture** and the **SamplerState** to the **GPU** before rendering.\n\n```swift\nclass TextureSampleMaterial: Material {\n\n    private var _textureType: BuiltInTexture!\n\n    init(_ textureType: BuiltInTexture) {\n        super.init()\n        fragmentFunctionName = FragmentFunctionNames.TextureSample\n        setTextureType(textureType)\n    }\n\n    func setTextureType(_ textureType: BuiltInTexture) {\n        _textureType = textureType\n    }\n\n    override func setGpuValues() {\n        Graphics.renderCommandEncoder.setFragmentSamplerState(SamplerStateCache.get(.Linear), index: 0)\n        Graphics.renderCommandEncoder.setFragmentTexture(TextureCache.get(_textureType), index: 0)\n    }\n}\n```\n\nThe **Game Object** initializes the **MeshRenderer** with the corresponding **Material** and **Texture**.\n\n```swift\nlet mesh = MeshCache.get(.Quad)\nlet material = TextureSampleMaterial(.MonaLisa)\n\nself.addComponent(MeshRenderer(mesh: mesh, material: material))\n```\n\n---\n\n## Shader\n\nIn the **Metal Shader** code, we will access the **Texture** and **SamplerState** from the corresponding **blocks of memory**.\n\n**sampler(0)** and **texture(0)** mean that we will access the desired elements at the specified indexes.\n\n```c\nfragment half4 texture_sample_fragment_shader(\n    const FragmentData IN [[ stage_in ]],\n\n    // sampler and texture2d coming in their corresponding memory blocks\n    sampler sampler2d [[ sampler(0) ]],\n    texture2d<float> texture [[ texture(0) ]]\n){\n    float4 color = texture.sample(sampler2d, IN.uv);\n    return half4(color.r, color.g, color.b, color.a);\n}\n```\n\n---\n\n## Result\n\nThe Quad now renders the texture using the UV texture coordinates.\n\n![Picture](/images/blog/metal-render-pipeline-part-14-uvs-loading-sampling-textures/cover.jpg)\n"}},"__N_SSG":true}