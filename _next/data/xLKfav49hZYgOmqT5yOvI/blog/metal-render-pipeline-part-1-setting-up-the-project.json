{"pageProps":{"post":{"slug":"metal-render-pipeline-part-1-setting-up-the-project","date":"2022-11-29T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Metal Render Pipeline Part 1: Setting up the Project","excerpt":"Following the amazing tutorial series by Rick Twohy, creating a basic macos app project in xcode using Swift and Storyboards. Utilizing the Metal Kit library to access the Metal APIs to render 3D graphics, initializing the basic components to setup the render pipeline and start outputing 3D graphics on the screen.","coverImageUrl":"/images/blog/metal-render-pipeline-part-1-setting-up-the-project/cover.jpg","coverImageSourceUrl":"https://unsplash.com/photos/ICTjWYzpoc0","coverVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n-   [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n-   [Introduction to Metal by Ludovico Cellentani](https://lcellentani.github.io/post/metal_introduction/)\n\n---\n\n## Table of Content\n\n-   [Creating the XCode project](#creating-the-xcode-project)\n-   [MTKView](#mtkview)\n-   [The Command Structure](#the-command-structure)\n    -   [Resources](#resources)\n-   [Basic Render Pipeline](#basic-render-pipeline)\n    -   [Code](#code)\n        -   [Shaders](#shaders)\n        -   [Game View](#game-view)\n    -   [Result](#result)\n\n---\n\n## Creating the XCode project\n\nWe just need to create a very basic **macOS** app using **Swift** and **Storyboards** for the UI.\n\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/1.jpg)\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/2.jpg)\n\n---\n\n## MTKView\n\n-   [MTK View](https://developer.apple.com/documentation/metalkit/mtkview)\n\nCreate a new **Cocoa Class** file, extending from **MTKView**, which in turn extends **NSView**.\n\nThis will be connected to your main **Storyboard** for the **Game View**, where we will output the rendering of the pipeline.\n\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/3.jpg)\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/4.jpg)\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/5.jpg)\n\n---\n\n## The Command Structure\n\n[Command Structure Images from Apple Docs](https://developer.apple.com/documentation/metal/gpu_devices_and_work_submission/setting_up_a_command_structure)\n\nThe **Metal** Graphics **API** uses a **Command Structure** to handle all the petitions from the **CPU** to render graphics in the **GPU**.\n\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/6.png)\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/9.jpg)\n\n[Render Pipeline Descriptor Image Source](https://lcellentani.github.io/post/metal_introduction/)\n\nThe **Command Buffers** contain the instructions the the **CPU** needs to execute.\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/7.png)\n\nThe **Command Queue** holds all the **Command Buffers** and ensures they execute timely and in order. It also handles executions and results coming to/from **Compute Shaders**.\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/8.png)\n\n### Resources\n\n-   [Metal Render Pipeline](https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives)\n\n    -   [Introduction to Metal by Ludovico Cellentani](https://lcellentani.github.io/post/metal_introduction/)\n\n-   [Setting up a Command Structure](https://developer.apple.com/documentation/metal/gpu_devices_and_work_submission/setting_up_a_command_structure)\n    -   [MTL Command Buffer](https://developer.apple.com/documentation/metal/mtlcommandbuffer)\n    -   [MTL Command Encoder](https://developer.apple.com/documentation/metal/mtlcommandencoder)\n        -   [MTL Render Command Encoder](https://developer.apple.com/documentation/metal/mtlrendercommandencoder)\n-   [MTL Render Pass Descriptor](https://developer.apple.com/documentation/metal/mtlrenderpassdescriptor)\n-   [MTL Render Pipeline State](https://developer.apple.com/documentation/metal/mtlrenderpipelinestate)\n\n    -   [MTL Render Pipeline Descriptor](https://developer.apple.com/documentation/metal/mtlrenderpipelinedescriptor)\n        -   Color Attachments\n            -   Pixel Format\n        -   Vertex/Fragment Functions\n            -   [MTL Library](https://developer.apple.com/documentation/metal/mtllibrary)\n                -   [MTL Function Type](https://developer.apple.com/documentation/metal/mtlfunctiontype)\n                    -   Vertex/Fragment/Kernel\n                -   [MTL Function](https://developer.apple.com/documentation/metal/mtlfunction)\n                    -   **.metal** files\n\n-   [MTL Device](https://developer.apple.com/documentation/metal/mtldevice)\n    -   [MTL Pixel Format](https://developer.apple.com/documentation/metal/mtlpixelformat)\n    -   [MTL Command Queue](https://developer.apple.com/documentation/metal/mtlcommandqueue)\n\n---\n\n## Basic Render Pipeline\n\n1. The **Device** represents the **GPU** device in the machine.\n1. From the **Device**, we create the **Commmand Queue**.\n1. We create **Command Buffers** using the **Command Queue**.\n1. The **Render Command Encoder** is created out of the **Command Buffer** (There are many types of **Command Encoders**, **Render** is for Graphics Rendering, **Compute** would be for Computations, as in Compute Shaders)\n    1. We use the **Render Pass Descriptor** for this, which includes information about the output buffers to show the result of the rendering.\n1. At one point we will set the **Render Pipeline State** to the **Render Command Encoder**.\n1. To create the **Render Pipeline State**, we first need to create the **Render Pipeline Descriptor**.\n    1. For creating the **Render Pipeline Descriptor**, we need to create a **Library** first, which will let us create the **Functions** for **Vertex** and **Fragment** calculations.\n    2. Once we have the **Library** and the **Functions**, we can create the **Render Pipeline Descriptor**.\n    3. With the **Render Pipeline Descriptor**, we can tell the **Device** to create the **Render Pipeline State**.\n1. Now we can set the **Render Pipeline State** to the **Render Command Encoder**.\n1. And we can tell the **Command Buffer** to **endEncoding()**, **present()** to the **drawable**, and **commit()** to schedule its execution.\n\n### Code\n\n#### Shaders\n\nFor defining the **Shaders**, we need to create a **Metal** file.\n\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/10.jpg)\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/11.jpg)\n\n```c\n#include <metal_stdlib>\nusing namespace metal;\n\nvertex float4 basic_vertex_shader(){\n    return float4(1);\n}\n\nfragment half4 basic_fragment_shader(){\n    return half4(1);\n}\n```\n\n#### Game View\n\nFor now this will just clear the screen with a basic green color, every frame.\n\n```swift\nimport MetalKit\n\nclass GameView: MTKView {\n\n    var commandQueue: MTLCommandQueue!\n    var renderPipelineState: MTLRenderPipelineState!\n\n    required init(coder: NSCoder) {\n        super.init(coder: coder)\n\n        // device is an abstract representation of the GPU\n        // allows to create Metal GPU objects and send them down to the GPU\n        self.device = MTLCreateSystemDefaultDevice()\n\n        // clearColor fills the screen each time the GPU clears the frame (60 times per second at 60 fps)\n        // rgba is 0-1\n        self.clearColor = MTLClearColor(red: 0.43, green: 0.73, blue: 0.35, alpha: 1.0)\n\n        // how pixels are stored\n        self.colorPixelFormat = MTLPixelFormat.bgra8Unorm\n\n        // create the command queue to handle commands for the GPU\n        self.commandQueue = device?.makeCommandQueue()\n\n        createRenderPipelineState()\n    }\n\n    func createRenderPipelineState(){\n\n        let library = device?.makeDefaultLibrary()\n\n        // at compile time it will pick the right vertex and shader functions by matching the names\n        let vertexFunction = library?.makeFunction(name: \"basic_vertex_shader\")\n        let fragmentFunction = library?.makeFunction(name: \"basic_fragment_shader\")\n\n        // create the descriptor for the render pipeline, make the pixel format match the device\n        let renderPipelineDescriptor = MTLRenderPipelineDescriptor()\n        renderPipelineDescriptor.colorAttachments[0].pixelFormat = MTLPixelFormat.bgra8Unorm\n\n        // set the vertex and fragment functions\n        renderPipelineDescriptor.vertexFunction = vertexFunction\n        renderPipelineDescriptor.fragmentFunction = fragmentFunction\n\n        // create the render pipeline state using the render pipeline descriptor\n        do {\n            renderPipelineState = try device?.makeRenderPipelineState(descriptor: renderPipelineDescriptor)\n        } catch let error as NSError {\n            print(error)\n        }\n    }\n\n    override func draw(_ dirtyRect: NSRect) {\n\n        // get references if available, else return\n        guard let drawable = self.currentDrawable, let renderPassDescriptor = self.currentRenderPassDescriptor else { return }\n\n        // cretae a command buffer\n        let commandBuffer = commandQueue.makeCommandBuffer()\n\n        // create the render command encoder\n        // pass the render pass descriptor, which includes pixel information and destination buffers\n        let renderCommandEncoder = commandBuffer?.makeRenderCommandEncoder(descriptor: renderPassDescriptor)\n\n        // set the render pipeline state to the render command encoder\n        renderCommandEncoder?.setRenderPipelineState(self.renderPipelineState)\n\n        // TODO: send info to render command encoder\n\n        // after passing all the data\n        renderCommandEncoder?.endEncoding()\n\n        // the command buffer will present the result of the rendering when it's done\n        commandBuffer?.present(drawable)\n\n        // execute the command buffer\n        commandBuffer?.commit()\n    }\n}\n```\n\n### Result\n\n![Picture](/images/blog/metal-render-pipeline-part-1-setting-up-the-project/12.jpg)\n"}},"__N_SSG":true}