{"pageProps":{"post":{"slug":"metal-render-pipeline-part-5-game-object-caches-renderer","date":"2022-12-21T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Metal Render Pipeline Part 5: Game Object, Objects Caches and Renderer","excerpt":"Organizing the code in sub classes to build the foundations of what is to come for this basic game engine. Delegating the rendering to an MTKViewDelegate, and also drawing the primitives in the dedicated Game Object class.","coverImageUrl":"/images/blog/metal-render-pipeline-part-5-game-object-caches-renderer/cover.jpg","coverImageSourceUrl":"https://unsplash.com/photos/CxE1H2_9B9s","coverVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n-   [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n\n---\n\n## Table of Content\n\n-   [Objects Caches](#objects-caches)\n-   [Game Object](#game-object)\n-   [Renderer](#renderer)\n-   [Game View](#game-view)\n\n---\n\n## Objects Caches\n\nWe will extract the code that initializes the **MTLLibrary**, **MTLRenderPipelineState**, **MTLRenderPipelineDescriptor** and **MTLVertexDescriptor** into separate classes.\n\nEach of these classes will act as a cache, with a dictionary mapping enum values to objects instances.\n\nThe pseudocode structure of these library classes will be like:\n\n```swift\nenum ElementType{\n    case Basic\n}\n\nclass ElementsCache<T> {\n\n    private static var _elements: [ElementType: T] = [:]\n\n    public static func Initialize(){\n        createElements()\n    }\n\n    public static func createElements(){\n        _elements.updateValue(BasicElement(), forKey: .Basic)\n    }\n\n    public static func GetElement(_ elementType: ElementType)->T{\n        return _elements[elementType]!\n    }\n\n}\n```\n\nThis will allow us to initialize the libraries in the **Engine** class:\n\n```swift\nclass Engine {\n\n    public static var Device: MTLDevice!\n    public static var CommandQueue: MTLCommandQueue!\n\n    public static func Initialize(device: MTLDevice){\n\n        // device is an abstract representation of the GPU\n        // allows to create Metal GPU objects and send them down to the GPU\n        self.Device = device\n\n        // create the command queue to handle commands for the GPU\n        self.CommandQueue = device.makeCommandQueue()\n\n        ShaderCache.Initialize()\n        VertexDescriptorCache.Initialize()\n        RenderPipelineDescriptorCache.Initialize()\n        RenderPipelineStateCache.Initialize()\n    }\n}\n```\n\n---\n\n## Game Object\n\nThe game object will be in charge of creating the **vertexBuffer** and **drawing its primitives**, for now. In the future this should be handled by the **Mesh Renderer** **component**.\n\nThe game object also has the **vertices** array for now, in the future this should be handled by a **Mesh** class.\n\n```swift\nclass GameObject {\n\n    var vertices: [Vertex]!\n    var vertexBuffer: MTLBuffer!\n\n    init() {\n        createVertices()\n        createBuffers()\n    }\n\n    func createVertices() {\n        // counter clock wise to define the face\n        vertices = [\n            Vertex(position: float3(0, 1, 0),   color: float4(0, 0, 1, 1)), // top mid\n            Vertex(position: float3(-1, -1, 0), color: float4(0, 1, 0, 1)), // bot left\n            Vertex(position: float3(1, -1, 0),  color: float4(1, 0, 0, 1)), // top right\n        ]\n    }\n\n    func createBuffers() {\n        vertexBuffer = Engine.Device.makeBuffer(bytes: vertices, length: Vertex.stride * vertices.count, options: [])\n    }\n\n    func render(renderCommandEncoder: MTLRenderCommandEncoder){\n\n        renderCommandEncoder.setRenderPipelineState(RenderPipelineStateLibrary.PipelineState(.Basic))\n        renderCommandEncoder.setVertexBuffer(self.vertexBuffer, offset: 0, index: 0)\n        renderCommandEncoder.drawPrimitives(type: MTLPrimitiveType.triangle, vertexStart: 0, vertexCount: self.vertices.count)\n    }\n}\n```\n\n---\n\n## Renderer\n\nTo further simplify the **GameView** class, we will use a **MTKViewDelegate** to take on the work of actually rendering the view at 60 fps.\n\nFor now it is also in charge of initializing the game objects, but that will be handled by the **Scene** in the future.\n\n```swift\nclass GameViewRenderer: NSObject {\n    var gameObject: GameObject = GameObject()\n}\n\n// we will delegate the rendering to this class\nextension GameViewRenderer: MTKViewDelegate {\n\n    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {\n        // when the window is resized\n    }\n\n    func draw(in view: MTKView){\n        guard let drawable = view.currentDrawable, let renderPassDescriptor = view.currentRenderPassDescriptor else { return }\n\n        let commandBuffer = Engine.CommandQueue.makeCommandBuffer()\n\n        let renderCommandEncoder = commandBuffer?.makeRenderCommandEncoder(descriptor: renderPassDescriptor)\n\n        self.gameObject.render(renderCommandEncoder: renderCommandEncoder!)\n\n        renderCommandEncoder?.endEncoding()\n        commandBuffer?.present(drawable)\n        commandBuffer?.commit()\n    }\n}\n```\n\n---\n\n## Game View\n\nNow the **Game View** is just in charge of **initializing itself**, **initializing the Engine**, and **delegating the rendering** to its delegate.\n\nIn the future this view will also be in charge of **capturing mouse and keyboard inputs**.\n\n```swift\nclass GameView: MTKView {\n\n    var renderer: GameViewRenderer!\n\n    required init(coder: NSCoder) {\n        super.init(coder: coder)\n\n        self.device = MTLCreateSystemDefaultDevice()\n        self.clearColor = Preferences.ClearColor\n        self.colorPixelFormat = Preferences.PixelFormat\n\n        Engine.Initialize(device: self.device!)\n\n        self.renderer = GameViewRenderer()\n        self.delegate = self.renderer\n    }\n}\n```\n"}},"__N_SSG":true}