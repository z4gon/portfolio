{"pageProps":{"post":{"slug":"metal-render-pipeline-part-3-vertex-fragment-shaders","date":"2022-12-01T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Metal Render Pipeline Part 3: Vertex and Fragment Shaders","excerpt":"Modeling the vertices data as structs in the CPU side, then passing this data through a buffer to the GPU. Modeling the data structures for vertex and fragment functions in the GPU side. Accessing the interpolated values after rasterization to render corresponding colors for pixels on screen.","coverImageUrl":"/resources/blog/metal-render-pipeline-part-3-vertex-fragment-shaders/cover.jpg","coverImageSourceUrl":"","coverVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n- [Using a Render Pipeline to Render Primitives](https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives)\n\n---\n\n## Table of Content\n\n- [Vertex Struct in CPU](#vertex-struct)\n- [Vertex Shader](#vertex-shader)\n- [Fragment Shader](#fragment-shader)\n- [Result](#result)\n\n---\n\n## Vertex Struct in CPU\n\nWe will expand the data definition for the vertices, including not only the **position** in **screen space**, but also the **color** of the vertices.\n\n```swift\nstruct Vertex {\n    var position: SIMD3<Float>\n    var color: SIMD4<Float>\n}\n```\n\n![Picture](/resources/blog/metal-render-pipeline-part-3-vertex-fragment-shaders/2.png)\n\n[Image Source üîó](https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives)\n\nThe vertices array now holds objects of this type, and we also need to account for this when calculating the **memory stride**.\n\n```swift\nvar vertices: [Vertex]!\n\nfunc createVertices() {\n    // counter clock wise to define the face\n    vertices = [\n        Vertex(position: SIMD3<Float>(0, 1, 0),   color: SIMD4<Float>(0, 0, 1, 1)), // top mid\n        Vertex(position: SIMD3<Float>(-1, -1, 0), color: SIMD4<Float>(0, 1, 0, 1)), // bot left\n        Vertex(position: SIMD3<Float>(1, -1, 0),  color: SIMD4<Float>(1, 0, 0, 1)), // top right\n    ]\n}\n\nfunc createBuffers() {\n    let vertexMemSize = MemoryLayout<Vertex>.stride\n\n    vertexBuffer = device?.makeBuffer(bytes: vertices, length: vertexMemSize * vertices.count, options: [])\n}\n```\n\n---\n\n## Vertex Shader\n\nSimilarly, in the **GPU side**, we need to **model the data** with the **closest data types**.\nWe will read elements off of the buffer, and will represent them with these structures.\n\nThe attribute `[[ position ]]` prevents the values interpolation from happening on it. **Color** will be **interpolated** **per fragment**, depending on its position in the triangle face, respect to the defining vertices.\n\nThe interpolation happens at the **Rasterizer** stage.\n\n![Picture](/resources/blog/metal-render-pipeline-part-3-vertex-fragment-shaders/3.png)\n\n[Image Source üîó](https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives)\n\n```swift\nstruct VertexData {\n    float3 position;\n    float4 color;\n};\n\nstruct FragmentData {\n    float4 position [[ position ]]; // use position attribute to prevent interpolation of the value\n    float4 color;\n};\n```\n\nNow the **vertex funciton** takes in an array of **VertexData**.\n\nWe also need to create a new **FragmentData** structure and populate it with the corresponding values.\n\n```swift\nvertex FragmentData basic_vertex_shader(\n  device VertexData *vertices [[ buffer(0) ]], // access the vertices buffer at buffer with index 0\n  uint vertexID [[ vertex_id ]] // get the vertex id, which corresponds to the index of the vertex in the buffer\n){\n    VertexData IN = vertices[vertexID];\n\n    FragmentData OUT;\n\n    OUT.position = float4(IN.position, 1); // return the vertex position in homogeneous screen space\n    OUT.color = IN.color;\n\n    return OUT; // return the vertex position in homogeneous screen space\n}\n```\n\n![Picture](/resources/blog/metal-render-pipeline-part-3-vertex-fragment-shaders/4.png)\n\n[Image Source üîó](https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives)\n\n---\n\n## Fragment Shader\n\nThe **fragment function** now takes in a **FragmentData** structure.\n\nWe get an **interpolated color** coming in, which we can use to paint the corresponding pixel.\n\n```swift\nfragment half4 basic_fragment_shader(FragmentData IN [[ stage_in ]]){\n    float4 color = IN.color;\n    return half4(color.r, color.g, color.b, color.a);\n}\n```\n\n![Picture](/resources/blog/metal-render-pipeline-part-3-vertex-fragment-shaders/5.png)\n\n[Image Source üîó](https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives)\n\n---\n\n## Result\n\n![Picture](/resources/blog/metal-render-pipeline-part-3-vertex-fragment-shaders/cover.jpg)\n"}},"__N_SSG":true}