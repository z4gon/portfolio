{"pageProps":{"post":{"slug":"metal-render-pipeline-part-15-loading-and-rendering-obj-models","date":"2023-01-02T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Metal Render Pipeline Part 15: Loading and Rendering .OBJ Models","excerpt":"Mesh References describing the .OBJ asset and how to load it. Mesh Loader to actually use ModelIO and load the MTKMeshes out of the .OBJ file, using a MTKModelIOVertexDescriptor. Extending the Mesh class to have two subclasses, the BuiltInMesh and the ModelMesh. The Model Mesh will have a reference to the MTKMesh with all the submeshes, vertex and index buffers. Modifying the Mesh Renderer to be able to render MTKMeshes. Using Texture References and Texture Loaders to load any needed texture for the models.","coverImageUrl":"/resources/blog/metal-render-pipeline-part-15-loading-and-rendering-obj-models/cover.jpg","coverImageSourceUrl":"","coverVideoUrl":"/resources/blog/metal-render-pipeline-part-15-loading-and-rendering-obj-models/1.mp4","markdownContent":"\n## Source Code\n\n[See Project in GitHub ðŸ‘©â€ðŸ’»](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n\n## Table of Content\n\n- [Model Mesh Reference](#model-mesh-reference)\n- [Model Mesh Loader](#model-mesh-loader)\n- [Mesh](#mesh)\n- [Mesh Renderer](#mesh-renderer)\n- [Textures](#textures)\n- [Model Game Object](#model-game-object)\n- [Result](#result)\n\n---\n\n## Model Mesh Reference\n\nThe **Model Mesh Reference** will point to the asset that we want to load from.\n\nIt will also have a **load()** method that will be in charge of initializing the actual **Mesh** object.\n\n```swift\nprotocol MeshReference {\n    var id: String! { get }\n    func load()->Mesh\n}\n\nclass ModelMeshReference : MeshReference {\n    public var name: String!\n    public var fileExtension: String! = \"obj\"\n    public var meshIndex: Int = 0\n\n    public var id: String! {\n        return \"\\(name!).\\(fileExtension!):\\(meshIndex)\"\n    }\n\n    init(\n        _ name: String,\n        fileExtension: String = \"obj\",\n        meshIndex: Int = 0\n    ){\n        self.name = name\n        self.fileExtension = fileExtension\n        self.meshIndex = meshIndex\n    }\n\n    func load()->Mesh {\n        return ModelMeshLoader(self).load()\n    }\n}\n```\n\nThis will act as an **identifier** when caching model meshes in the corresponding cache.\n\n```swift\n    public var id: String! {\n        return \"\\(name!).\\(fileExtension!):\\(meshIndex)\"\n    }\n```\n\n```swift\nclass MeshCache : Cache<MeshReference, Mesh> {\n\n    private static var _meshes: [String: Mesh] = [:]\n\n    override class func get(_ meshReference: MeshReference)->Mesh{\n\n        if(!_meshes.keys.contains(meshReference.id)) {\n            _meshes.updateValue(meshReference.load(), forKey: meshReference.id)\n        }\n\n        return _meshes[meshReference.id]!\n    }\n}\n```\n\n---\n\n## Model Mesh Loader\n\nWill be in charge of actually using **ModelIO** to load the data for the **vertices** from the **.obj** file.\n\nIt will **initialize** a **vertex descriptor** off of our **metal BasicVertexDescriptor**.\n\nSince **.obj** files can contain **multiple meshes** inside, we will also just return the one specified in the **mesh reference**.\n\n```swift\nclass ModelMeshLoader {\n    private var _meshReference: ModelMeshReference!\n\n    init(_ meshReference: ModelMeshReference) {\n        _meshReference = meshReference\n    }\n\n    public func load()->Mesh {\n        guard let url = Bundle.main.url(forResource: _meshReference.name, withExtension: _meshReference.fileExtension) else {\n            fatalError(\"ERROR::LOADING::MODEL::__\\(_meshReference.name!).\\(_meshReference.fileExtension!)__::does not exist\")\n        }\n\n        let vertexDescriptor = MTKModelIOVertexDescriptorFromMetal(VertexDescriptorCache.get(.Basic))\n\n        // make each attribute mapped to each attribute type\n        (vertexDescriptor.attributes[0] as! MDLVertexAttribute).name = MDLVertexAttributePosition\n        (vertexDescriptor.attributes[1] as! MDLVertexAttribute).name = MDLVertexAttributeNormal\n        (vertexDescriptor.attributes[2] as! MDLVertexAttribute).name = MDLVertexAttributeColor\n        (vertexDescriptor.attributes[3] as! MDLVertexAttribute).name = MDLVertexAttributeTextureCoordinate\n\n        let bufferAllocator = MTKMeshBufferAllocator(device: Engine.device)\n        let asset: MDLAsset = MDLAsset(\n            url: url,\n            vertexDescriptor: vertexDescriptor,\n            bufferAllocator: bufferAllocator\n        )\n\n        var meshes: [Any]! = []\n        do {\n            meshes = try MTKMesh.newMeshes(asset: asset, device: Engine.device).metalKitMeshes\n        } catch {\n            print(\"ERROR::LOADING::MODEL::__\\(_meshReference.name!).\\(_meshReference.fileExtension!)__::\\(error)\")\n        }\n\n        return ModelMesh(loadedMesh: meshes[_meshReference.meshIndex])\n    }\n}\n```\n\n---\n\n## Mesh\n\n**Meshes** now differentiate, **BuiltIn Meshes** have just a **vertex buffer** and an **index buffer**.\n\n**Model Meshes** have a **MTKMesh** inside, that will grant access to the different vertex and index buffers.\n\n```swift\nclass Mesh {}\n\nclass BuiltInMesh : Mesh {\n    public var vertices: [Vertex]! = []\n    public var indices: [UInt32]! = []\n\n    public var vertexBuffer: MTLBuffer!\n    public var indexBuffer: MTLBuffer!\n\n    override init() {\n        super.init()\n        createMesh()\n\n        vertexBuffer = Engine.device.makeBuffer(bytes: vertices, length: Vertex.stride * vertices.count, options: [])\n\n        if(indices.count > 0){\n            indexBuffer = Engine.device.makeBuffer(bytes: indices, length: UInt32.stride * indices.count, options: [])\n        }\n    }\n\n    func createMesh() {}\n}\n\nclass ModelMesh : Mesh {\n    public var mtkMesh: MTKMesh? = nil\n\n    init(loadedMesh: Any) {\n        super.init()\n\n        if let metalKitMesh = loadedMesh as? MTKMesh {\n            self.mtkMesh = metalKitMesh\n        }\n    }\n}\n```\n\n---\n\n## Mesh Renderer\n\nThe **Mesh Renderer** will decide how to render the mesh, depending on if it's a **built in mesh**, or a **model mesh**.\n\n```swift\nfunc doRender() {\n\n    Graphics.renderCommandEncoder.setRenderPipelineState(RenderPipelineStateCache.get(_material))\n\n    // Vertex Shader data\n    Graphics.renderCommandEncoder.setVertexBytes(&_modelConstants, length: ModelConstants.stride, index: 1) // model matrix\n\n    _material.setGpuValues()\n\n    Graphics.renderCommandEncoder.setDepthStencilState(DepthStencilStateCache.get(.Less))\n\n    let mesh = MeshCache.get(_meshReference)\n\n    if let builtInMesh = mesh as? BuiltInMesh {\n        renderBuiltInMesh(builtInMesh)\n    } else if let modelMesh = mesh as? ModelMesh {\n        renderModelMesh(modelMesh)\n    }\n}\n\nfunc renderBuiltInMesh(_ mesh: BuiltInMesh) {\n    Graphics.renderCommandEncoder.setVertexBuffer(mesh.vertexBuffer, offset: 0, index: 0)\n\n    if(mesh.indices.count > 0){\n        Graphics.renderCommandEncoder.drawIndexedPrimitives(\n            type: MTLPrimitiveType.triangle,\n            indexCount: mesh.indices.count,\n            indexType: MTLIndexType.uint32,\n            indexBuffer: mesh.indexBuffer,\n            indexBufferOffset: 0,\n            instanceCount: 1 // for now, might change in the future\n        )\n    } else {\n        Graphics.renderCommandEncoder.drawPrimitives(\n            type: MTLPrimitiveType.triangle,\n            vertexStart: 0,\n            vertexCount: mesh.vertices.count\n        )\n    }\n}\n\nfunc renderModelMesh(_ mesh: ModelMesh) {\n\n    if(mesh.mtkMesh == nil) { return }\n\n    for vertexBuffer in mesh.mtkMesh!.vertexBuffers {\n        Graphics.renderCommandEncoder.setVertexBuffer(vertexBuffer.buffer, offset: vertexBuffer.offset, index: 0)\n\n        for submesh in mesh.mtkMesh!.submeshes {\n            Graphics.renderCommandEncoder.drawIndexedPrimitives(\n                type: submesh.primitiveType,\n                indexCount: submesh.indexCount,\n                indexType: submesh.indexType,\n                indexBuffer: submesh.indexBuffer.buffer,\n                indexBufferOffset: submesh.indexBuffer.offset,\n                instanceCount: 1 // for now, might change in the future\n            )\n        }\n    }\n}\n```\n\n---\n\n## Textures\n\nSimilar to how we handle meshes, **Textures** will have a **Texture Reference** that will act as an id in the **Texture Cache**.\n\n```swift\nclass TextureReference {\n    public var name: String!\n    public var fileExtension: String! = \"jpg\"\n    public var textureLoaderOrigin: MTKTextureLoader.Origin! = MTKTextureLoader.Origin.topLeft\n\n    public var id: String! {\n        return \"\\(name!).\\(fileExtension!):\\(textureLoaderOrigin!)\"\n    }\n\n    init(\n        _ name: String,\n        fileExtension: String = \"jpg\",\n        textureLoaderOrigin: MTKTextureLoader.Origin = MTKTextureLoader.Origin.topLeft\n    ){\n        self.name = name\n        self.fileExtension = fileExtension\n        self.textureLoaderOrigin = textureLoaderOrigin\n    }\n\n    func load()->MTLTexture {\n        return TextureLoader(self).load()\n    }\n}\n```\n\nAnd the **Texture Reference** will use the **Texture Loader** to load the corresponding **MTLTexture**.\n\n```swift\nclass TextureLoader {\n    private var _textureReference: TextureReference!\n\n    init(_ textureReference: TextureReference) {\n        _textureReference = textureReference\n    }\n\n    public func load()->MTLTexture {\n        var result: MTLTexture!\n\n        guard let url = Bundle.main.url(forResource: _textureReference.name, withExtension: _textureReference.fileExtension) else {\n            fatalError(\"ERROR::LOADING::TEXTURE::__\\(_textureReference.name!).\\(_textureReference.fileExtension!)__::does not exist\")\n        }\n\n        let loader = MTKTextureLoader(device: Engine.device)\n        let options: [MTKTextureLoader.Option: Any] = [MTKTextureLoader.Option.origin : _textureReference.textureLoaderOrigin!]\n\n        do {\n            result = try loader.newTexture(URL: url, options: options)\n            result.label = _textureReference.name\n        } catch let error as NSError {\n            print(\"ERROR::LOADING::TEXTURE::__\\(_textureReference.name!).\\(_textureReference.fileExtension!)__::\\(error)\")\n        }\n\n        return result\n    }\n}\n```\n\nThis will allow us to load any texture asset, without needing an enumerator.\n\n```swift\nclass TextureCache : Cache<TextureReference, MTLTexture> {\n\n    private static var _textures: [String: MTLTexture] = [:]\n\n    override class func get(_ textureReference: TextureReference)->MTLTexture{\n\n        if(!_textures.keys.contains(textureReference.id)) {\n            _textures.updateValue(textureReference.load(), forKey: textureReference.id)\n        }\n\n        return _textures[textureReference.id]!\n    }\n}\n```\n\n---\n\n## Model Game Object\n\nWill take in a **Mesh Reference** and a **Texture Reference**.\n\nInternally it will add a **Mesh Renderer** using the **mesh reference**, and also will set the **Material** to **sample the texture** using the **texture coordinates**.\n\n```swift\nclass ModelGameObject : GameObject {\n\n    init(\n        modelMeshReference: ModelMeshReference,\n        textureReference: TextureReference\n    ) {\n        super.init()\n\n        let material = TextureSampleMaterial(textureReference)\n\n        self.addComponent(MeshRenderer(meshReference: modelMeshReference, material: material))\n        self.addComponent(RotateYComponent())\n    }\n}\n```\n\nTo set up the **scene** that uses our **Samus.obj** file, we need to do:\n\n```swift\nlet samusGameObject = ModelGameObject(\n    modelMeshReference: ModelMeshReference(\"samus\"),\n    textureReference: TextureReference(\"samus\", fileExtension: \"png\", textureLoaderOrigin: MTKTextureLoader.Origin.bottomLeft)\n)\n```\n\n---\n\n## Result\n\nThe screen now shows the **3D model of Samus**, with its **base texture** correctly sampled.\n\n![Picture](/resources/blog/metal-render-pipeline-part-15-loading-and-rendering-obj-models/cover.jpg)\n"}},"__N_SSG":true}