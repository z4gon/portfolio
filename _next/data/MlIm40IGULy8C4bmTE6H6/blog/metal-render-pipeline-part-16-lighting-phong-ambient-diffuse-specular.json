{"pageProps":{"post":{"slug":"metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular","date":"2023-01-05T00:00:00.000Z","author":{"name":"z4gon","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Lighting, Ambient, Diffuse and Specular (Metal Part 16)","excerpt":"Defining light objects with properties like position, color, intensity, range. Collecting and passing down to the GPU all light information. Defining standard surface values in the material, like color and glossiness. Accessing the material and lights information from the corresponding buffers in the lit fragment shader. Defining the structure of the mathematical model of Phong shading. Calculating ambient illumination using the color, intensity and attenuation. Calculating the diffuse using the dot product between the normals and the light direction. Calculating the specular by refracting the light direction along the normals, and doing the dot product by the direction to the camera.","heroImageUrl":"/resources/blog/metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular/cover.jpg","heroImageSourceUrl":"","heroVideoUrl":"/resources/blog/metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular/1.mp4","markdownContent":"\n## Source Code\n\n[See Project in GitHub 👩‍💻](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n- [MSL: const, constant and device](https://stackoverflow.com/questions/59010429/what-the-purpose-of-declaring-a-variable-with-const-constant)\n- [C arrays behave as pointers](https://stackoverflow.com/questions/2094666/pointers-in-c-when-to-use-the-ampersand-and-the-asterisk)\n- [C Pointers](https://www.programiz.com/c-programming/c-pointers)\n\n## Table of Content\n\n- [Light Component](#light-component)\n- [Light Data](#light-data)\n- [Light Manager](#light-manager)\n- [Scene](#scene)\n- [Material](#material)\n- [Material Data](#material-data)\n- [Lit Shader](#lit-shader)\n  - [Attenuation](#attenuation)\n  - [Ambient](#ambient)\n  - [Diffuse](#diffuse)\n  - [Specular](#specular)\n- [Result](#result)\n\n---\n\n## Light Component\n\nWill be in charge of keeping the **position** of the **light**, by reusing the **transform object**.\nAlso generates the **Light Data** whenever requested.\n\n```swift\nenum LightType {\n    case Point\n    case Directional\n}\n\nclass Light : Component {\n\n    public var type: LightType = LightType.Point\n\n    public var intensity: Float = 1\n    public var ambient: Float = 0.3\n    public var color: float4 = Colors.White\n\n    public var range: Float = 0.6\n\n    private var _data: LightData = LightData()\n    public var data: LightData! {\n\n        _data.position = gameObject.position\n        _data.color = color\n        _data.intensity = intensity\n        _data.ambient = ambient\n        _data.range = range\n\n        return _data\n    }\n}\n```\n\n---\n\n## Light Data\n\nIs just a **struct** that can be passed down to the **GPU** with the relevant **Light information**.\n\n```swift\nstruct LightData: sizeable {\n    var position: float3 = float3(repeating: 0)\n    var color: float4 = Colors.White\n    var intensity: Float = 1\n    var ambient: Float = 0.3\n    var range: Float = 0.6\n}\n```\n\nThe **GPU** will also define a struct to access the data from the **buffer**.\n\n```c\nstruct LightData {\n    float3 position;\n    float4 color;\n    float intensity;\n    float ambient;\n    float range;\n};\n```\n\n---\n\n## Light Manager\n\nEach time a **light component** is added to a **game object**, the **light manager** keeps track of it.\n\n```swift\nclass GameObject : Transform {\n    private var _components: [Component]! = []\n\n    public func addComponent(_ component: Component){\n        _components.append(component)\n        component.setGameObject(self)\n\n        // set the camera as the main camera\n        if let camera  = component as? Camera {\n            CameraManager.mainCamera = camera\n        }\n\n        // keep track of the lights\n        if let light  = component as? Light {\n            LightManager.addLight(light)\n        }\n    }\n}\n```\n\nThe **Light Manager** is in charge of generating the **buffer** with all the **Light Data**.\n\nIt's very inefficient to do this on each cycle, but for siplicity we will keep it like this for now.\n\n```swift\nclass LightManager {\n    public static var lightsBuffer: MTLBuffer? {\n        if(_lights.count == 0) { return nil }\n\n        _lightDatas = []\n        for light in _lights {\n            _lightDatas.append(light.data)\n        }\n\n        // ineficcient, but will do for now\n        // we need an updated position of the lights\n        return Engine.device.makeBuffer(bytes: _lightDatas, length: LightData.stride * _lightDatas.count , options: [])\n    }\n\n    public static var lightsCount: Int! {\n        return _lights.count\n    }\n\n    private static var _lightDatas: [LightData]! = []\n    private static var _lights: [Light]! = []\n    private static var _lightsBuffer: MTLBuffer!\n\n    static func addLight(_ light: Light) {\n        _lights.append(light)\n    }\n}\n```\n\n---\n\n## Scene\n\nNow also sets the **Light Data** buffer whenever there are lights on the **scene**.\n\n```swift\noverride func render() {\n\n    updateSceneConstants()\n\n    // set the view matrix and projection matrix\n    Graphics.renderCommandEncoder.setVertexBytes(&_sceneConstants, length: SceneConstants.stride, index: 2)\n\n    // set light data\n    if LightManager.lightsCount > 0 {\n        var lightsCount = LightManager.lightsCount\n        Graphics.renderCommandEncoder.setFragmentBuffer(LightManager.lightsBuffer, offset: 0, index: 1)\n        Graphics.renderCommandEncoder.setFragmentBytes(&lightsCount, length: Int32.stride, index: 2)\n    }\n\n    super.render()\n}\n```\n\n---\n\n## Material\n\nMaterials now also have some common **surface properties**, like **color** and **glossiness**.\nIn the future they can also have **standard surface properties** like **emission**, **metallic**, **albedo**, **normal maps**, etc.\n\nBy default, **Materials** set their **values** to the **GPU** in the **fragment buffer 0**.\n\n```swift\nclass Material {\n    public var materialData: MaterialData = MaterialData()\n\n    public var vertexFunctionName: String = VertexFunctionNames.Basic\n    public var fragmentFunctionName: String = FragmentFunctionNames.VertexColor\n\n    public var renderPipelineStateId: String {\n        return \"\\(vertexFunctionName)/\\(fragmentFunctionName)\"\n    }\n\n    func setColor(_ color: float4){\n        materialData.color = color\n    }\n\n    func setGlossiness(_ glossiness: Float){\n        materialData.glossiness = glossiness\n    }\n\n    func setGpuValues() {\n        Graphics.renderCommandEncoder.setFragmentBytes(&materialData, length: MaterialData.stride, index: 0)\n    }\n}\n```\n\n---\n\n## Material Data\n\nIs just a **struct** that can be passed down to the **GPU** with the relevant **Material values**.\n\n```swift\nstruct MaterialData: sizeable {\n    public var color: float4 = Colors.White\n    public var glossiness: Float = 2\n}\n```\n\nThe **GPU** will also define a struct to access the data from the **buffer**.\n\n```c\nstruct MaterialData {\n    float4 color;\n    float glossiness;\n};\n```\n\n---\n\n## Lit Shader\n\nThe **general structure** of the **lit shader** that **samples textures** will be like below.\nIt takes in the **material properties** to access the **glossiness** for the **specular calculation**.\nThe **lights** will come in an array, each with their poisition and other relevant data.\n\nThe **fragment shader** will also have access to **the camera position**, and the **normals** of the fragments.\n\n```c\nfragment half4 lit_texture_sample_fragment_shader(\n    const FragmentData IN [[ stage_in ]],\n\n    constant MaterialData & materialData [[ buffer(0) ]],\n\n    constant LightData * lights [[ buffer(1) ]],\n    constant int & lightsCount [[ buffer(2) ]],\n\n    // sampler and texture2d coming in their corresponding memory blocks\n    sampler sampler2d [[ sampler(0) ]],\n    texture2d<float> texture [[ texture(0) ]]\n){\n    // sample texture\n    float4 color = texture.sample(sampler2d, IN.uv);\n\n    for(int i = 0; i < lightsCount; i++){\n        LightData light = lights[i];\n\n        // TODO: CALCULATE PHONG LIGHTING\n    }\n\n    float4 phong = totalAmbient + totalDiffuse + totalSpecular;\n    color = color * phong;\n\n    return half4(color.r, color.g, color.b, color.a);\n}\n```\n\n### Attenuation\n\nWe calculate a **linear attenuation** to make the light **intensity fade away** the farther away we are from the light, given a **range**.\n\n```c\nLightData light = lights[i];\n\n// light direction\nfloat4 lightDir = float4(light.position.xyz, 1) - IN.worldPosition;\n\n// attenuation\nfloat distanceToLight = length(lightDir);\nfloat attenuation = 1 - clamp(distanceToLight/light.range, 0.0, 1.0);\n```\n\n### Ambient\n\nThe **ambient** is calculated using the **ambient intensity** of the **light**, its **color** and the **attenuation**.\n\n```c\n// ambient\nfloat4 ambient = light.color * light.ambient * attenuation;\n```\n\n![Picture](/resources/blog/metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular/1.jpg)\n\n### Diffuse\n\nThe **diffuse** is calculated by doing the **DOT product** between the **surface normal** and the **light direction** vector.\nThe more the **surface** is to a **90 degree to the light direction**, or past it **facing away from the light**, the **darker** it's going to be.\n\n```c\n// diffuse\nfloat nDotL = max(dot(normalize(IN.worldNormal), normalize(lightDir)), 0.0);\nfloat4 diffuse =  light.color * nDotL * light.intensity * attenuation;\n```\n\n![Picture](/resources/blog/metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular/2.jpg)\n\n### Specular\n\nThe **specular** is calculated by **reflecting** the **light direction** by the **surface normal vector**.\nThen doing the **DOT product** between the **reflected light direction** and the **view direction**.\n\nThe more the rays are pointing to the camera, the brighter.\n\nFinally we do a **power** by the **glossiness** defined in the **material**, the more glossiness, the **sharper** the **reflections** will be.\n\n```c\n// specular\nfloat3 viewDir = IN.cameraPosition - IN.worldPosition.xyz;\nfloat3 reflectedLightDir = reflect(-normalize(lightDir.xyz), normalize(IN.worldNormal.xyz));\nfloat vDotL = max(0.0, dot(reflectedLightDir, normalize(viewDir))); // avoid negative values\nvDotL = pow(vDotL, materialData.glossiness);\nfloat4 specular =  light.color * vDotL * light.intensity * attenuation;\n```\n\n![Picture](/resources/blog/metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular/3.jpg)\n\n---\n\n## Result\n\nThe **3D model of Samus** is now correclty illuminated with **ambient**, **diffuse** and **specular** components.\n\n![Picture](/resources/blog/metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular/cover.jpg)\n![Picture](/resources/blog/metal-render-pipeline-part-16-lighting-phong-ambient-diffuse-specular/5.jpg)\n"}},"__N_SSG":true}