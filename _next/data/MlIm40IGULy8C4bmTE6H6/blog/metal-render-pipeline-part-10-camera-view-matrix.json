{"pageProps":{"post":{"slug":"metal-render-pipeline-part-10-camera-view-matrix","date":"2022-12-28T02:00:00.000Z","author":{"name":"z4gon","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Camera and View Matrix (Metal Part 10)","excerpt":"Implementing a Camera Component to calculate a view matrix. Updating the view matrix and passing it down to the GPU. Using the view matrix during the vertex shader function to transform the vertex coordinates to view space.","heroImageUrl":"/resources/blog/metal-render-pipeline-part-10-camera-view-matrix/cover.jpg","heroImageSourceUrl":"","heroVideoUrl":"/resources/blog/metal-render-pipeline-part-10-camera-view-matrix/1.mp4","markdownContent":"\n## Source Code\n\n[See Project in GitHub 👩‍💻](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n\n---\n\n## Table of Content\n\n- [Camera Component](#camera-component)\n- [Scene](#scene)\n- [Shader](#shader)\n- [Result](#result)\n\n---\n\n## Camera Component\n\nThe **Camera** is implemented as a **component** attached to a **game object**, it reuses the **position** of the **transform** to calculate the **view matrix**.\n\nThe calculation of the **view matrix** is done in the early update method.\n\n```swift\nclass Camera : Component, EarlyUpdatable {\n\n    public var viewMatrix: float4x4 = matrix_identity_float4x4\n    public var type: CameraType = CameraType.Perspective\n\n    func updateViewMatrix() {\n        var result: float4x4 = matrix_identity_float4x4\n\n        // the world needs to move in the opposite direction than the camera\n        result.translate(position: -gameObject.position)\n//        result.scale(scale: gameObject.scale)\n//\n//        result.rotateX(angle: gameObject.rotation.x)\n//        result.rotateY(angle: gameObject.rotation.y)\n//        result.rotateZ(angle: gameObject.rotation.z)\n\n        viewMatrix = result\n    }\n\n    // to ensure all other components get the accurate camera position\n    func doEarlyUpdate(deltaTime: Float) {\n        updateViewMatrix()\n    }\n}\n```\n\nThe **Debug Camera** will use the arrow keys to move horizontally and vertically.\n\nThis is done in the **early update** as well, so that other components can use the accurate camera position. (Such as getting the world position corresponding to the mouse position)\n\n```swift\nclass DebugCameraComponent : Camera {\n\n    override func doEarlyUpdate(deltaTime: Float) {\n\n        if(Keyboard.isKeyPressed(KeyCodes.upArrow)){\n            gameObject.position.y += deltaTime\n        }\n\n        if(Keyboard.isKeyPressed(KeyCodes.downArrow)){\n            gameObject.position.y -= deltaTime\n        }\n\n        if(Keyboard.isKeyPressed(KeyCodes.leftArrow)){\n            gameObject.position.x -= deltaTime\n        }\n\n        if(Keyboard.isKeyPressed(KeyCodes.rightArrow)){\n            gameObject.position.x += deltaTime\n        }\n\n        super.doEarlyUpdate(deltaTime: deltaTime)\n    }\n}\n```\n\nThe components can then use the camera position when trying to get the mouse position in the screen.\n\n```swift\npublic static func getMouseViewportPosition(_ camera: Camera)->float2{\n    let viewportPosition = getMouseViewportPosition()\n    return float2(viewportPosition.x + camera.gameObject.position.x, viewportPosition.y + camera.gameObject.position.y)\n}\n```\n\n---\n\n## Scene\n\nThe **Scene** now holds a struct with the Scene Constants, which will include the **view matrix** and the **projection matrix** for the **perspective projection**.\n\nThe **view matrix** is updated by the camera itself, and since the camera will be used as the main camera in the scene, it will be used to update the view matrix in the scene.\n\n**Once** per render cycle, the scene will pass the **Scene Constants** with the **view matrix** to the **GPU** as bytes by value. Similarly to how the Mesh Renderer passes the model constants with the model matrix to the GPU.\n\n```swift\nclass Scene : Transform {\n\n    private var _sceneConstants: SceneConstants! = SceneConstants()\n\n    func updateSceneConstants() {\n        _sceneConstants.viewMatrix = CameraManager.mainCamera.viewMatrix\n    }\n\n    override func render(renderCommandEncoder: MTLRenderCommandEncoder) {\n\n        updateSceneConstants()\n\n        // set the view matrix\n        renderCommandEncoder.setVertexBytes(&_sceneConstants, length: SceneConstants.stride, index: 2)\n\n        super.render(renderCommandEncoder: renderCommandEncoder)\n    }\n}\n```\n\n---\n\n## Shader\n\nThe **Vertex Shader** function will pick up the **Scene Constants** and the **view matrix** off of the buffer.\n\nIt will multiply the matrices with the object space position of the vertex, to transform the coordinates to view space.\n\n```c\nfloat4 viewSpaceCoordinates = viewMatrix * modelMatrix * objectSpaceCoordinates\n```\n\n```c\nvertex FragmentData basic_vertex_shader(\n  // metal can infer the data because we are describing it using the vertex descriptor\n  const VertexData IN [[ stage_in ]],\n  constant ModelConstants &modelConstants [[ buffer(1) ]],\n  constant SceneConstants &sceneConstants [[ buffer(2) ]]\n){\n    FragmentData OUT;\n\n    // return the vertex position in homogeneous screen space\n    // ProjectionMatrix * ViewMatrix * ModelMatrix * ObjectPosition = HSCPosition\n    OUT.position = sceneConstants.viewMatrix * modelConstants.modelMatrix * float4(IN.position, 1);\n\n    OUT.color = IN.color;\n\n    return OUT;\n}\n```\n\n---\n\n## Result\n\nPressing the keyboard arrows now moves the camera along the x and y coordinates.\n\n![Picture](/resources/blog/metal-render-pipeline-part-10-camera-view-matrix/cover.jpg)\n"}},"__N_SSG":true}