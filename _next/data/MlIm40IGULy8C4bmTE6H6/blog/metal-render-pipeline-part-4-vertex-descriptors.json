{"pageProps":{"post":{"slug":"metal-render-pipeline-part-4-vertex-descriptors","date":"2022-12-20T00:00:00.000Z","author":{"name":"z4gon","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Vertex Descriptors (Metal Part 4)","excerpt":"Describing the memory layout for the vertices in the vertex buffer, so the vertex shader can pick them up individually.","heroImageUrl":"/resources/blog/metal-render-pipeline-part-4-vertex-descriptors/cover.jpg","heroImageSourceUrl":"https://unsplash.com/photos/COFXWa6LJdw","heroVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n- [Size vs Stride in Swift](https://swiftunboxed.com/internals/size-stride-alignment/)\n\n---\n\n## Table of Content\n\n- [Vertex Descriptor](#vertex-descriptor)\n- [Vertex Shader](#vertex-shader)\n- [Result](#result)\n\n---\n\n## Vertex Descriptor\n\n- [MTLVertexDescriptor](https://developer.apple.com/documentation/metal/mtlvertexdescriptor)\n- [MTLVertexAttributeDescriptor](https://developer.apple.com/documentation/metal/mtlvertexattributedescriptor)\n\nCreate a **MTL Vertex Descriptor** and start defining the **attributes**.\n\nThis will allow the shader to just grab the individual vertex off of the vertex buffer, without needing to access the whole vertices array and extracting the vertex with the vertex id.\n\n```swift\n// set the vertex descriptor\nlet vertexDescriptor = MTLVertexDescriptor()\n\n// position\n// - first attribute, metal will use the attributes tags like so [[ attribute(0) ]]\n// - buffer index means the vertices are in the [[ buffer(0) ]] in metal\n// - no offset inside the struct, it's just the first attribute\nvertexDescriptor.attributes[0].format = MTLVertexFormat.float3\nvertexDescriptor.attributes[0].bufferIndex = 0\nvertexDescriptor.attributes[0].offset = 0\n\n// color\n// - second attribute, metal will use the attributes tags like so [[ attribute(1) ]]\n// - buffer index means the vertices are in the [[ buffer(0) ]] in metal\n// - offset inside the struct, needs to be the amount of memory of the position, in bytes\nvertexDescriptor.attributes[1].format = MTLVertexFormat.float4\nvertexDescriptor.attributes[1].bufferIndex = 0\nvertexDescriptor.attributes[1].offset = float3.size()\n\n// layout, how the pipeline state describes the struct\n// https://swiftunboxed.com/internals/size-stride-alignment/\nvertexDescriptor.layouts[0].stride = Vertex.stride()\n\nrenderPipelineDescriptor.vertexDescriptor = vertexDescriptor\n```\n\n### Size vs Stride\n\nThe Stride will always be greater than or equal to the size.\n\nIt can be greater sometimes to favor memory alignment.\n\n![Picture](/resources/blog/metal-render-pipeline-part-4-vertex-descriptors/1.png)\n\n[Image Source üîó](https://swiftunboxed.com/internals/size-stride-alignment/)\n\n---\n\n## Vertex Shader\n\nThe struct for the Vertex Data now needs to describe the attributes using the indexes that correspond to the vertex descriptor attributes, with `[[ attribute(n) ]]`.\n\n```c\nstruct VertexData {\n    float3 position [[ attribute(0) ]];\n    float4 color [[ attribute(1) ]];\n};\n```\n\nThe Vertex Shader can now just take in the corresponding Vertex Data struct using `[[ stage_in ]]`, because the GPU now has a description of the elements.\n\n```c\nvertex FragmentData basic_vertex_shader(\n  // metal can infer the data because we are describing it using the vertex descriptor\n  const VertexData IN [[ stage_in ]]\n){\n    FragmentData OUT;\n\n    // return the vertex position in homogeneous screen space\n    OUT.position = float4(IN.position, 1);\n    OUT.color = IN.color;\n\n    return OUT;\n}\n```\n\n---\n\n## Result\n\nThe end result hasn't changed.\n\n![Picture](/resources/blog/metal-render-pipeline-part-4-vertex-descriptors/2.jpg)\n"}},"__N_SSG":true}