{"pageProps":{"post":{"slug":"metal-render-pipeline-part-13-materials-multiple-render-pipeline-descriptors-states","date":"2023-01-01T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Materials, Multiple Render Pipeline Descriptors and States (Metal Part 13)","excerpt":"Defining materials with different vertex, fragment functions and attributes. Maintaining multiple render pipeline descriptors and states to match the different materials being used. Passing values to the GPU from the materials. Setting the corresponding render pipeline state to the render command encoder, based on the current material attached to the mesh renderer.","heroImageUrl":"/resources/blog/metal-render-pipeline-part-13-materials-multiple-render-pipeline-descriptors-states/cover.jpg","heroImageSourceUrl":"","heroVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n\n## Table of Content\n\n- [Material](#material)\n- [MTLRenderPipelineDescriptor](#mtlrenderpipelinedescriptor)\n- [Mesh Renderer](#mesh-renderer)\n- [Shader](#shader)\n- [Result](#result)\n\n---\n\n## Material\n\nThe **materials** will have references to the names of the **functions** used for the **Vertex Shader** and **Fragment Shader** stages.\n\n```swift\nclass Material {\n    public var vertexFunctionName: String = VertexFunctionNames.Basic\n    public var fragmentFunctionName: String = FragmentFunctionNames.VertexColor\n\n    public var renderPipelineStateId: String {\n        return \"\\(vertexFunctionName)/\\(fragmentFunctionName)\"\n    }\n\n    func setGpuValues() {}\n}\n```\n\nSpecific **instances** of **Materials**, will also optionally have other attributes.\n\nAnd also will set **values** to the **GPU** via the **Render Command Encoder**, using **.setVertexBytes** and **.setFragmentBytes**.\n\n```swift\nclass FillColorMaterial: Material {\n\n    private var _color: float4 = float4(repeating: 0)\n\n    init(_ color: float4) {\n        super.init()\n        fragmentFunctionName = FragmentFunctionNames.FillColor\n        _color = color\n    }\n\n    func setColor(_ color: float4) {\n        _color = color\n    }\n\n    override func setGpuValues() {\n        Graphics.renderCommandEncoder.setFragmentBytes(&_color, length: float4.stride, index: 1)\n    }\n}\n```\n\n---\n\n## MTLRenderPipelineDescriptor\n\nThe **render pipeline descriptor** will use the functions defined in the **material**, which will be reused for any i**nstances of Mat**erials that use the same **combination** of **Vertex/Fragment shaders**.\n\n```swift\npublic struct RenderPipelineDescriptor{\n    ...\n\n    init(material: Material){\n\n        // create the descriptor for the render pipeline\n        _renderPipelineDescriptor = MTLRenderPipelineDescriptor()\n\n        ...\n\n        _renderPipelineDescriptor.vertexFunction = VertexShaderCache.get(material.vertexFunctionName)\n        _renderPipelineDescriptor.fragmentFunction = FragmentShaderCache.get(material.fragmentFunctionName)\n\n        ...\n    }\n}\n```\n\nThere will also be a **render pipeline state** associated to the combination of **vertex and fragment functions** used by the **material**.\n\n```swift\npublic struct RenderPipelineState {\n    var renderPipelineState: MTLRenderPipelineState!\n\n    init(material: Material){\n        do{\n            renderPipelineState = try Engine.device.makeRenderPipelineState(descriptor: RenderPipelineDescriptorCache.get(material))\n        }catch let error as NSError {\n            print(\"ERROR::CREATE::RENDER_PIPELINE_STATE::__\\(material.renderPipelineStateId)__::\\(error)\")\n        }\n    }\n}\n```\n\n---\n\n## Mesh Renderer\n\nThe mesh renderer will now configure the render command encoder to use the appropriate render pipeline state, according to the associated material.\n\nAlso, before rendering, it will execute the material function to setGpuValues()\n\n```swift\nclass MeshRenderer : Component, Renderable, LateUpdatable {\n\n    ...\n    private var _material: Material!\n\n    init(mesh: Mesh, material: Material) {\n        ...\n\n        _material = material\n    }\n\n    ...\n\n    func doRender() {\n\n        Graphics.renderCommandEncoder.setRenderPipelineState(RenderPipelineStateCache.get(_material))\n\n        ...\n\n        _material.setGpuValues()\n\n        ...\n    }\n}\n```\n\n---\n\n## Shader\n\nThe **metal shader** can now pickup the **passed in values** directly off of the **buffers**.\n\n```c\nfragment half4 fill_color_fragment_shader(\n    const FragmentData IN [[ stage_in ]],\n    constant float4 &color [[ buffer(1) ]]\n){\n    return half4(color.r, color.g, color.b, color.a);\n}\n```\n\nThese values were set by the material earlier:\n\n```swift\noverride func setGpuValues() {\n    Graphics.renderCommandEncoder.setFragmentBytes(&_color, length: float4.stride, index: 1)\n}\n```\n\n---\n\n## Result\n\nNow the quad is using a different fragment function than the cube, because the render command encoder is using different render pipeline states.\n\n![Picture](/resources/blog/metal-render-pipeline-part-13-materials-multiple-render-pipeline-descriptors-states/cover.jpg)\n"}},"__N_SSG":true}