{"pageProps":{"post":{"slug":"metal-render-pipeline-part-7-3d-affine-transformation-matrices","date":"2022-12-27T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"3D Affine Transformation Matrices (Metal Part 7)","excerpt":"Implementing transformation matrices to convert vertex positions from object space to world space, using the model matrix for transformations. Passing the matrix to the CPU using a buffer, and then doing the matrix multiplication for each vertex in the vertex shader function","heroImageUrl":"/resources/blog/metal-render-pipeline-part-7-3d-affine-transformation-matrices/cover.jpg","heroImageSourceUrl":"","heroVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n- [Spatial Transformation Matrices](https://www.brainvoyager.com/bv/doc/UsersGuide/CoordsAndTransforms/SpatialTransformationMatrices.html)\n\n---\n\n## Table of Content\n\n- [Translation](#translation)\n- [Scaling](#scaling)\n- [Rotation](#rotation)\n- [Shader](#shader)\n- [Result](#result)\n\n---\n\n## Translation\n\nThe Affine **translation** **matrix** allows to transform the **position** of the game object.\n\n```swift\nmutating func translate(position: float3) {\n    var result = matrix_identity_float4x4\n\n    let x = position.x\n    let y = position.y\n    let z = position.z\n\n    result.columns = (\n        float4(1, 0, 0, 0),\n        float4(0, 1, 0, 0),\n        float4(0, 0, 1, 0),\n        float4(x, y, z, 1)\n    )\n\n    self = matrix_multiply(self, result)\n}\n```\n\n---\n\n## Scaling\n\nThe Affine **scaling** **matrix** allows to transform the **scale** of the game object.\n\n```swift\nmutating func scale(scale: float3) {\n    var result = matrix_identity_float4x4\n\n    let x = scale.x\n    let y = scale.y\n    let z = scale.z\n\n    result.columns = (\n        float4(x, 0, 0, 0),\n        float4(0, y, 0, 0),\n        float4(0, 0, z, 0),\n        float4(0, 0, 0, 1)\n    )\n\n    self = matrix_multiply(self, result)\n}\n```\n\n---\n\n## Rotation\n\nThe **rotation** **matrix** depends on the **axis** of **rotation** and the **angle** of rotation.\n\nThese matrices introduce the **gimbal lock** problem, which is solved by using **Quaternions** for rotations, but for now this is enough.\n\n```swift\nmutating func rotateX(angle: Float) {\n    var result = matrix_identity_float4x4\n\n    let s = sin(angle)\n    let c = cos(angle)\n\n    result.columns = (\n        float4(1, 0, 0, 0),\n        float4(0, c, s, 0),\n        float4(0, -s, c, 0),\n        float4(0, 0, 0, 1)\n    )\n\n    self = matrix_multiply(self, result)\n}\n\nmutating func rotateY(angle: Float) {\n    var result = matrix_identity_float4x4\n\n    let s = sin(angle)\n    let c = cos(angle)\n\n    result.columns = (\n        float4(c, 0, -s, 0),\n        float4(0, 1, 0, 0),\n        float4(s, 0, c, 0),\n        float4(0, 0, 0, 1)\n    )\n\n    self = matrix_multiply(self, result)\n}\n\nmutating func rotateZ(angle: Float) {\n    var result = matrix_identity_float4x4\n\n    let s = sin(angle)\n    let c = cos(angle)\n\n    result.columns = (\n        float4(c, s, 0, 0),\n        float4(-s, c, 0, 0),\n        float4(0, 0, 1, 0),\n        float4(0, 0, 0, 1)\n    )\n\n    self = matrix_multiply(self, result)\n}\n```\n\n---\n\n## Shader\n\nThe **MeshRenderer** now also keeps a **transformation matrix**, called the **model matrix**, to represent the transformations for the **vertices**, given the **position**, **scale** and **rotation** of the **transform**.\n\nIt also passes it down to the **CPU** so it can use it to transform the vertices.\n\nThe struct holding the model constants is passed by value, as bytes, in a buffer for the **CPU**.\n\nHere we do **updateModelConstants()** as part of the rendering, it should be part of the **update()** stage for optimization purposes. For simplicity we will do it here, to avoid issues with order of execution of the components in the game object.\n\nWe will also need to take into consideration parent transforms in the future.\n\n```swift\nclass MeshRenderer : Component, Renderable {\n\n    private var _modelConstants: ModelConstants! = ModelConstants()\n\n    ...\n\n    func updateModelConstants() {\n        var modelMatrix: float4x4 = matrix_identity_float4x4\n\n        modelMatrix.translate(position: gameObject.position)\n        modelMatrix.scale(scale: gameObject.scale)\n\n        modelMatrix.rotateX(angle: gameObject.rotation.x)\n        modelMatrix.rotateY(angle: gameObject.rotation.y)\n        modelMatrix.rotateZ(angle: gameObject.rotation.z)\n\n        _modelConstants.modelMatrix = modelMatrix\n    }\n\n    func doRender(renderCommandEncoder: MTLRenderCommandEncoder) {\n\n        updateModelConstants()\n\n        // set the transformation matrix\n        renderCommandEncoder.setVertexBytes(&_modelConstants, length: ModelConstants.stride, index: 1)\n\n        renderCommandEncoder.setRenderPipelineState(RenderPipelineStateCache.getPipelineState(.Basic))\n        renderCommandEncoder.setVertexBuffer(_vertexBuffer, offset: 0, index: 0)\n        renderCommandEncoder.drawPrimitives(type: MTLPrimitiveType.triangle, vertexStart: 0, vertexCount: _mesh.vertices.count)\n    }\n}\n```\n\nIn the **Shader** code, we define the same structure, and we add a new parameter to the vertex function.\n\nBy doing a **matrix multiplication** between the **model matrix** and the **vertex position** in **object space**, we get the new transformed position of the vertex.\n\n```c\nstruct ModelConstants {\n    float4x4 modelMatrix;\n};\n\nvertex FragmentData basic_vertex_shader(\n  // metal can infer the data because we are describing it using the vertex descriptor\n  const VertexData IN [[ stage_in ]],\n  constant ModelConstants &modelConstants [[ buffer(1) ]]\n){\n    FragmentData OUT;\n\n    // return the vertex position in homogeneous screen space\n    OUT.position = modelConstants.modelMatrix * float4(IN.position, 1);\n\n    OUT.color = IN.color;\n\n    return OUT;\n}\n```\n\n---\n\n## Result\n\nNow the mesh translates, scales and rotates.\n\n![Picture](/resources/blog/metal-render-pipeline-part-7-3d-affine-transformation-matrices/cover.jpg)\n"}},"__N_SSG":true}