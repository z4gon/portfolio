{"pageProps":{"post":{"slug":"metal-render-pipeline-part-8-scene-graph","date":"2022-12-28T00:00:00.000Z","author":{"name":"Gonzalo Cumini","pictureUrl":"/images/avatars/z4gon.jpg"},"title":"Scene Graph (Metal Part 8)","excerpt":"Implementing a Scene Object and a Scene Manager, to be able to render many objects and decouple the state out of the Game View Renderer.","heroImageUrl":"/resources/blog/metal-render-pipeline-part-8-scene-graph/cover.jpg","heroImageSourceUrl":"","heroVideoUrl":"","markdownContent":"\n## Source Code\n\n[See Project in GitHub üë©‚Äçüíª](https://github.com/z4gon/metal-render-pipeline)\n\n## References\n\n- [Metal Render Pipeline tutorial series by Rick Twohy](https://www.youtube.com/playlist?list=PLEXt1-oJUa4BVgjZt9tK2MhV_DW7PVDsg)\n\n---\n\n## Table of Content\n\n- [Scene](#scene)\n- [Scene Manager](#scene-manager)\n- [Testing Objects](#testing-objects)\n- [Result](#result)\n\n---\n\n## Scene\n\nThe **Scene** will also be a **Transform** object, it will be the **root** transform of the scene.\n\n```swift\nclass Scene : Transform {\n\n    override init(){\n        super.init()\n        buildScene()\n    }\n\n    func buildScene() {}\n}\n```\n\n---\n\n## Scene Manager\n\nThe **Scene Manager** will be in charge of holding the current scene, in the future it can implement transitions between scenes, and handling loading and unloading of resources.\n\nIt also offers a public function to update and render the current scene.\n\n```swift\nenum SceneType {\n    case Sandbox\n}\n\nclass SceneManager {\n\n    private static var _currentScene: Scene!\n\n    public static func initialize(_ sceneType: SceneType){\n        setScene(sceneType)\n    }\n\n    public static func setScene(_ sceneType: SceneType){\n        switch sceneType {\n            case .Sandbox:\n                _currentScene = SandboxScene()\n        }\n    }\n\n    public static func tickScene(deltaTime: Float, renderCommandEncoder: MTLRenderCommandEncoder) {\n        _currentScene.update(deltaTime: deltaTime)\n        _currentScene.render(renderCommandEncoder: renderCommandEncoder)\n    }\n}\n```\n\nThis can later be used in the Game View Renderer class, to decouple it from scene initialization.\n\n```swift\nextension GameViewRenderer: MTKViewDelegate {\n\n    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {\n        // when the window is resized\n    }\n\n    func draw(in view: MTKView){\n        ...\n\n        SceneManager.tickScene(deltaTime: 1.0 / Float(view.preferredFramesPerSecond), renderCommandEncoder: renderCommandEncoder!)\n\n        renderCommandEncoder?.endEncoding()\n        commandBuffer?.present(drawable)\n        commandBuffer?.commit()\n    }\n}\n```\n\n---\n\n## Testing Objects\n\nTo setup our **testing scene**, we can make use of all the **testing classes** we have created which inherit from our base classes.\n\n```swift\nclass MoveComponent : Component, Updatable {\n\n    var time: Float = 0\n\n    func doUpdate(deltaTime: Float) {\n        time += deltaTime\n\n//        gameObject.position = float3(cos(time), gameObject.position.y, gameObject.position.z)\n//        gameObject.scale = float3(repeating: sin(time))\n        gameObject.rotation = float3(gameObject.rotation.x, gameObject.rotation.y, sin(time))\n    }\n}\n\nclass QuadGameObject : GameObject {\n\n    override init() {\n        super.init()\n\n        let meshRenderer = MeshRenderer(mesh: MeshCache.getMesh(.Quad))\n        self.addComponent(component: meshRenderer)\n\n        let moveComponent = MoveComponent()\n        self.addComponent(component: moveComponent)\n    }\n}\n\nclass SandboxScene : Scene {\n\n    override func buildScene() {\n\n        for y in -5..<5 {\n            for x in -5..<5 {\n                let gameObject = QuadGameObject()\n\n                gameObject.position.y = Float(Float(y) + 0.5) / 5\n                gameObject.position.x = Float(Float(x) + 0.5) / 5\n                gameObject.scale = float3(repeating: 0.15)\n\n                addChild(transform: gameObject)\n            }\n        }\n    }\n}\n```\n\nThe Game Engine can then initialize itself with a sandbox scene by default.\n\n```swift\nclass Engine {\n\n    public static func initialize(device: MTLDevice){\n\n        ...\n\n        SceneManager.initialize(Preferences.InitialScene)\n    }\n}\n```\n\n---\n\n## Result\n\nNow the scene contains lots of game objects and all **update** and **render** accordingly.\n\n![Picture](/resources/blog/metal-render-pipeline-part-8-scene-graph/cover.jpg)\n"}},"__N_SSG":true}